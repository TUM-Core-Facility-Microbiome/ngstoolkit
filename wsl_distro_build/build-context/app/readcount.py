#!/usr/bin/env python3

"""Count lines of Miseq run."""

import argparse
import os
import logging
from time import sleep

def log_to_status_file(msg):
    with open('/usr/local/bin/status.txt', 'w') as stat_f_h:
        stat_f_h.write(msg)


parser = argparse.ArgumentParser()
parser.add_argument('path', type=str)
parser.add_argument('statsout', type=str)
parser.add_argument('tobepairedout', type=str)
parser.add_argument('--mapping', type=str)
parser.add_argument('--log-failed', type=str)
args = parser.parse_args()

stats_out_path = args.statsout
tobepaired_out_path = args.tobepairedout

log_failed = args.log_failed
if log_failed:
    log_fails_and_continue = True
    log_failed_path = log_failed
    with open(log_failed_path, 'w') as _:
        pass

# path is extracted from the command line argument <path>
e_path = args.path
logging.debug(e_path)
# a given path . will be translated to the current working directory
if e_path == ".":
    e_path = os.getcwd()

pathToFolder = os.path.abspath(e_path)
parentPath = os.path.dirname(pathToFolder)


# helper functions
def addBackToString(array, seperator):
    """
    Reconstruct a string from a list that was splitted by 'sperator'.
    This only works for one occurence of 'seperator' in the original string.

    :param array: (list) A list of length 2 that was generated by splitting a string with 'seperator'
    :param seperator: (str) A string to insert between part one and two of the 'array'
    :return: (str) Part 1 will be concatenated with seperator and with part 2 of the array
    """
    return array[0] + seperator + array[1]


def inspectFilename(fastq_filename):
    """
    Process a fastq filename and guess the filename of the matching reverse or forward file.
    Return the ID, the ID with .fastq appended (IDFastq), if it used _R1_ or _R2_ (this_seperator), and the filename of a matching file (matchingFile)

    :param fastq_filename: (str) A filename of a fastq file containing _R1_ or _R2_
    :return: (tuple) A tuple with ID, IDFastq, this_seperator, matchingFile
    """
    fn = fastq_filename.split("_R1_")
    # splitted filenames will be arrays so we see if it was splitted by _R1_
    if len(fn) == 1:
        # no _R1_ in string
        fn = fastq_filename.split("_R2_")
        if len(fn) == 2:
            this_seperator = "_R2_"
            other_seperator = "_R1_"
        else:
            raise Exception("InspectFilename function failed for file: " + fastq_filename)
    elif len(fn) == 2:
        # already separated on _R1_ substring
        this_seperator = "_R1_"
        other_seperator = "_R2_"

    ID = fastq_filename.split('_')[:-4]
    ID = '_'.join(ID)
    IDFastq = '_'.join(ID) + ".fastq"

    return (ID, IDFastq, this_seperator, addBackToString(fn, other_seperator))


def file_len(fname):
    """
    Get the number of lines in a file

    :param fname: (str) filename
    :return: (int) Number of lines in file
    """
    try:
        with open(fname) as f:
            for i, l in enumerate(f):
                pass
            return i + 1
    except UnboundLocalError as e:
        failedFilenames.append("EMPTY " + str(fname))
        print(str(
            e) + " while counting lines for file {}. This probably means this file is empty.".format(
            fname))
        return 0
    except Exception as e:
        raise


def gzip(file):
    os.popen('gzip ' + file + ' -f').read()
    return file + ".gz"


logging.basicConfig(
    level=logging.DEBUG
)

mapping = []
mapping_given = False
if args.mapping is not None:
    mapping_given = True
    with open(args.mapping, 'r') as mapping_file_h:
        for line in mapping_file_h:
            if line.startswith('#'):
                continue
            fields = line.split('\t')
            mapping.append(fields[0])

logging.debug(f'entries of mapping file: {mapping!r}')

# Generate headers of tab files
# stats_string_tab = "Sample_ID\tDemultiplexing\n"
stats_string_tab = ""
tobepaired_string_tab = "#Forward\tReverse\tID\tfasta\n"

ignore = []  # array of already matched files as we iterate filename by filename
i = 0  # an iterator for processed files
failed = 0  # an iterator counting the failed attempts to get the linecount, this means the file did not exist
failedFilenames = []  # collecting the filenames that failed in a list

# transverse a given folder
for file in os.listdir(pathToFolder):
    # exclude I1 and I2 files by adding them to the ignore list
    if (len(file.split("_I1_")) != 1) or (len(file.split("_I2_")) != 1):
        ignore.append(file)

    # ignore files that were already processed from its matching partner and files that are not fastq files
    if file not in ignore and file.endswith(".fastq"):
        failedInThisIteration = False

        (ID, IDFastq, R, matching) = inspectFilename(file)
        ignore.append(matching)

        # dont process files that are not in given mapping file
        if mapping_given:
            if ID not in mapping:
                logging.warning(f'Ignoring ID {ID!r} as it is not in the given mapping file.')
                continue

        if R == "_R1_":
            forwardFile = file
            reverseFile = matching
        elif R == "_R2_":
            forwardFile = matching
            reverseFile = file

        # count lines in forward file
        try:
            fwCount = file_len(pathToFolder + "/" + forwardFile)
        except FileNotFoundError:
            fwCount = 0
            failedInThisIteration = True
            failed += 1
            failedFilenames.append(forwardFile)
            forwardFile = "None"

        # count lines in reverse file
        try:
            rwCount = file_len(pathToFolder + "/" + reverseFile)
        except FileNotFoundError:
            rwCount = 0
            failedInThisIteration = True
            failed += 1
            failedFilenames.append(reverseFile)
            reverseFile = "None"

        # generate count for demultiplexing
        # we assume that the counts are the same for rw file and fw file
        if fwCount != rwCount:
            print("ERROR: Counts not the same in forward and reverse for files {} and {}".format(forwardFile,
                                                                                                 reverseFile))
            if not log_fails_and_continue:
                exit(1)
            else:
                log_to_status_file('WARNING: Readcount failed for a file. Process continues...')
                with open(log_failed_path, 'a') as f:
                    f.write(
                        f"{forwardFile}\tERROR: Counts not the same in forward and reverse for files {forwardFile} and {reverseFile}\n")

        # test if the count can be divided by 4 as assumed
        if fwCount % 4 != 0:
            print(f"ERROR: Assumption that there are 4 lines per sample in a fastq file failed for {forwardFile}")

            if not log_fails_and_continue:
                exit(1)
            else:
                log_to_status_file('WARNING: Readcount failed for a file. Process continues...')
                with open(log_failed_path, 'a') as f:
                    f.write(
                        f"{forwardFile}\tERROR: Assumption that there are 4 lines per sample in a fastq file failed for {forwardFile}\n")

        # divide the lines in a fastq file by 4 to get the number of sequences per file
        count = fwCount // 4

        # add to the output strings
        if not failedInThisIteration:
            stats_string_tab += str(ID)
            stats_string_tab += "\t"
            stats_string_tab += str(count)
            stats_string_tab += "\n"

            tobepaired_string_tab += str(forwardFile)
            tobepaired_string_tab += "\t"
            tobepaired_string_tab += str(reverseFile)
            tobepaired_string_tab += "\t"
            tobepaired_string_tab += str(ID)
            tobepaired_string_tab += "\t"
            tobepaired_string_tab += str(ID + ".fasta")
            tobepaired_string_tab += "\n"

            i += 1

# print some output about failed attempts
processedFiles = i * 2
print("\nSuccessfully processed {} files.\n{} failed: {}".format(processedFiles, failed, str(failedFilenames)))

sleep(3)

if processedFiles > 0:
    with open(stats_out_path, "w") as file:
        file.write(stats_string_tab)

    with open(tobepaired_out_path, "w") as file:
        file.write(tobepaired_string_tab)
else:
    # there were no fastq files in that folder
    print("\nNo files to generate, because no files were processed.")

    if processedFiles == 0 and failed == 0:
        print("You maybe want to unzip files first.")
    else:
        print("Make sure there are .fastq files in the folder.")
    exit(1)
